#!/bin/sh

NHSSTA=../build/bin/nhssta

# Track overall success
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Tolerance for floating-point comparisons (relative error)
# LAT values (mean, stddev): 1.6% (0.016) - actual max error is ~1.33% in large circuits
# Correlation values: 3.8% (0.038) - actual max error is ~3.12%
# Sensitivity values (dF/dmu, dF/dsigma): 2.0% (0.02) - gradient values typically have small errors
# MAX operation is commutative, so different calculation order causes small differences
# LAT values typically have smaller errors (~0.07-0.41% in small circuits, up to ~1.33% in large circuits)
# Correlation values can accumulate more error due to multiple MAX operations (up to ~3.12%)
LAT_TOLERANCE=0.016
CORR_TOLERANCE=0.038
SENS_TOLERANCE=0.02

# Function to print section header
print_section() {
    echo ""
    echo "=========================================="
    echo "$1"
    echo "=========================================="
}

# Function to print success
print_success() {
    echo "✓ $1"
}

# Function to print failure
print_failure() {
    echo "✗ $1"
}

# Function to compare two numerical values with tolerance
# Returns 0 if values are within tolerance, 1 otherwise
compare_numerical() {
    VAL1="$1"
    VAL2="$2"
    TOL="$3"
    
    # Use awk for floating-point comparison
    awk -v val1="$VAL1" -v val2="$VAL2" -v tol="$TOL" '
    BEGIN {
        diff = val1 - val2
        if (diff < 0) diff = -diff
        # Use relative error if values are not too small
        if (val1 != 0 && val2 != 0) {
            rel_err = diff / (val1 > val2 ? val1 : val2)
            if (rel_err <= tol) exit 0
        }
        # Use absolute error for small values
        if (diff <= tol) exit 0
        exit 1
    }'
}

# Function to compare two files with numerical tolerance
# Uses Python for reliable floating-point comparison
compare_files_numerical() {
    FILE1="$1"
    FILE2="$2"
    TOL="$3"
    
    # Check if files exist
    if [ ! -f "$FILE1" ] || [ ! -f "$FILE2" ]; then
        return 1
    fi
    
    # Use Python for numerical comparison
    python3 -c "
import sys
import re

def is_numeric(s):
    try:
        float(s)
        return True
    except ValueError:
        return False

def compare_values(val1_str, val2_str, tol):
    try:
        val1 = float(val1_str)
        val2 = float(val2_str)
        diff = abs(val1 - val2)
        
        # Use relative error if values are not too small
        if abs(val1) > 1e-10 and abs(val2) > 1e-10:
            rel_err = diff / max(abs(val1), abs(val2))
            return rel_err <= tol
        else:
            # Use absolute error for small values
            return diff <= tol
    except ValueError:
        return False

def compare_lines(line1, line2, tol):
    if line1 == line2:
        return True
    
    # Split by whitespace (both space and tab)
    fields1 = re.split(r'[ \t]+', line1.strip())
    fields2 = re.split(r'[ \t]+', line2.strip())
    
    # Remove empty fields
    fields1 = [f for f in fields1 if f]
    fields2 = [f for f in fields2 if f]
    
    if len(fields1) != len(fields2):
        return False
    
    for f1, f2 in zip(fields1, fields2):
        if is_numeric(f1) and is_numeric(f2):
            if not compare_values(f1, f2, tol):
                return False
        else:
            if f1 != f2:
                return False
    
    return True

# Read files
file1 = '$FILE1'
file2 = '$FILE2'
tol = $TOL

try:
    with open(file1, 'r') as f1, open(file2, 'r') as f2:
        lines1 = f1.readlines()
        lines2 = f2.readlines()
        
        if len(lines1) != len(lines2):
            sys.exit(1)
        
        for l1, l2 in zip(lines1, lines2):
            if not compare_lines(l1, l2, tol):
                sys.exit(1)
    
    sys.exit(0)
except Exception:
    sys.exit(1)
" 2>/dev/null
}

# Function to run a single test
run_test() {
    TEST_NAME="$1"
    DLIB_FILE="$2"
    BENCH_FILE="$3"
    OPTIONS="$4"
    RESULT_FILE="$5"
    TEMP_RESULT_FILE="${RESULT_FILE}_"

    TOTAL_TESTS=$((TOTAL_TESTS + 1))
    echo "Test ${TOTAL_TESTS}: ${TEST_NAME} (${OPTIONS})"
    CMD_PREVIEW="${NHSSTA} ${OPTIONS} -d ${DLIB_FILE} -b ${BENCH_FILE}"
    echo "  Command: ${CMD_PREVIEW}"

    rm -f "${TEMP_RESULT_FILE}"

    # Check if this is a sensitivity test (options contain -s)
    # For sensitivity tests, keep comment lines (they contain important info like Objective value)
    # For other tests, filter out comment lines
    if echo "${OPTIONS}" | grep -q "\-s"; then
        # Sensitivity test: keep comment lines, filter version and OK line
        if ! ${NHSSTA} ${OPTIONS} -d "${DLIB_FILE}" -b "${BENCH_FILE}" 2>&1 | \
            grep -v "^nhssta " | \
            grep -v "^OK$" | \
            grep -v "RandomVariableImpl.*is creating" | \
            grep -v "RandomVariableImpl.*is deleting" \
            > "${TEMP_RESULT_FILE}"; then
            print_failure "  ✗ FAILED (nhssta execution failed)"
            FAILED_TESTS=$((FAILED_TESTS + 1))
            return 1
        fi
    else
        # Regular test: filter comments, version, timestamp, and OK line
        if ! ${NHSSTA} ${OPTIONS} -d "${DLIB_FILE}" -b "${BENCH_FILE}" 2>&1 | \
            grep -v "^#" | \
            grep -v "^nhssta " | \
            grep -v "^OK$" | \
            grep -v "RandomVariableImpl.*is creating" | \
            grep -v "RandomVariableImpl.*is deleting" \
            > "${TEMP_RESULT_FILE}"; then
            FAILED_TESTS=$((FAILED_TESTS + 1))
            return 1
        fi
    fi

    # Compare with expected result using numerical tolerance
    # LAT tolerance: 1.6%, Correlation tolerance: 3.8%, Sensitivity tolerance: 2.0%
    COMPARE_OUTPUT=$(python3 compare_numerical.py "${TEMP_RESULT_FILE}" "${RESULT_FILE}" "${LAT_TOLERANCE}" "${CORR_TOLERANCE}" "${SENS_TOLERANCE}" 2>/dev/null)
    COMPARE_EXIT_CODE=$?
    
    # Extract maximum errors from output using awk (compatible with macOS)
    MAX_LAT_ERROR=$(echo "${COMPARE_OUTPUT}" | awk -F'MAX_LAT_ERROR:' '{print $2}' | awk '{print $1}' | awk -F'MAX_CORR_ERROR:' '{print $1}')
    MAX_CORR_ERROR=$(echo "${COMPARE_OUTPUT}" | awk -F'MAX_CORR_ERROR:' '{print $2}' | awk '{print $1}' | awk -F'MAX_SENS_ERROR:' '{print $1}')
    MAX_SENS_ERROR=$(echo "${COMPARE_OUTPUT}" | awk -F'MAX_SENS_ERROR:' '{print $2}')
    
    # Default to 0.0 if extraction failed
    if [ -z "${MAX_LAT_ERROR}" ] || [ "${MAX_LAT_ERROR}" = "" ]; then
        MAX_LAT_ERROR="0.000000"
    fi
    if [ -z "${MAX_CORR_ERROR}" ] || [ "${MAX_CORR_ERROR}" = "" ]; then
        MAX_CORR_ERROR="0.000000"
    fi
    if [ -z "${MAX_SENS_ERROR}" ] || [ "${MAX_SENS_ERROR}" = "" ]; then
        MAX_SENS_ERROR="0.000000"
    fi
    
    # Convert to percentage
    MAX_LAT_PCT=$(echo "${MAX_LAT_ERROR}" | awk '{printf "%.2f", $1 * 100}')
    MAX_CORR_PCT=$(echo "${MAX_CORR_ERROR}" | awk '{printf "%.2f", $1 * 100}')
    MAX_SENS_PCT=$(echo "${MAX_SENS_ERROR}" | awk '{printf "%.2f", $1 * 100}')
    
    # Calculate tolerance percentages
    LAT_TOL_PCT=$(echo "${LAT_TOLERANCE}" | awk '{printf "%.2f", $1 * 100}')
    CORR_TOL_PCT=$(echo "${CORR_TOLERANCE}" | awk '{printf "%.2f", $1 * 100}')
    SENS_TOL_PCT=$(echo "${SENS_TOLERANCE}" | awk '{printf "%.2f", $1 * 100}')
    
    # Determine if this is a sensitivity test
    IS_SENSITIVITY_TEST=false
    if echo "${OPTIONS}" | grep -q "\-s"; then
        IS_SENSITIVITY_TEST=true
    fi
    
    if [ ${COMPARE_EXIT_CODE} -eq 0 ]; then
        if [ "${IS_SENSITIVITY_TEST}" = "true" ]; then
            print_success "  ✓ PASSED (最大誤差: 感度 ${MAX_SENS_PCT}%)"
        else
            print_success "  ✓ PASSED (最大誤差: LAT ${MAX_LAT_PCT}%, 相関 ${MAX_CORR_PCT}%)"
        fi
        PASSED_TESTS=$((PASSED_TESTS + 1))
        rm -f "${TEMP_RESULT_FILE}" # Clean up on success
    else
        if [ "${IS_SENSITIVITY_TEST}" = "true" ]; then
            print_failure "  ✗ FAILED (最大誤差: 感度 ${MAX_SENS_PCT}%, 許容: 感度 ${SENS_TOL_PCT}%)"
        else
            print_failure "  ✗ FAILED (最大誤差: LAT ${MAX_LAT_PCT}%, 相関 ${MAX_CORR_PCT}%, 許容: LAT ${LAT_TOL_PCT}%, 相関 ${CORR_TOL_PCT}%)"
        fi
        echo "    --- Diff for ${TEST_NAME} ---"
        # Show diff for debugging, but use numerical comparison for pass/fail
        diff -u "${TEMP_RESULT_FILE}" "${RESULT_FILE}" | head -30
        echo "    -----------------------------"
        FAILED_TESTS=$((FAILED_TESTS + 1))
    fi
    return 0
}

print_section "Running nhssta integration tests"

# Test cases
run_test "my.dlib + my.bench" "my.dlib" "my.bench" "-l -c -p" "result1"
run_test "ex4_gauss.dlib + ex4.bench" "ex4_gauss.dlib" "ex4.bench" "-l -c -p" "result2"
run_test "ex4_gauss.dlib + s27.bench" "ex4_gauss.dlib" "s27.bench" "-l -c -p" "result3"
run_test "gaussdelay.dlib + s298.bench" "gaussdelay.dlib" "s298.bench" "-l -p" "result4"
run_test "gaussdelay.dlib + s344.bench" "gaussdelay.dlib" "s344.bench" "-l -p" "result5"
run_test "gaussdelay.dlib + s820.bench" "gaussdelay.dlib" "s820.bench" "-l -p" "result6"
run_test "ex4_gauss.dlib + ex3.bench" "ex4_gauss.dlib" "ex3.bench" "-l -c -p" "result7"
run_test "dos.dlib + dos.bench" "dos.dlib" "dos.bench" "-l -c -p" "result8"

print_section "Sensitivity Analysis Tests"

# Sensitivity analysis tests
# Note: Sensitivity values may have small numerical differences due to floating-point precision
# Using LAT tolerance (1.6%) for sensitivity values as well
run_test "ex4_gauss.dlib + s27.bench (sensitivity)" "ex4_gauss.dlib" "s27.bench" "-s -n 3" "result_sensitivity_s27_expected"
run_test "ex4_gauss.dlib + ex4.bench (sensitivity)" "ex4_gauss.dlib" "ex4.bench" "-s -n 5" "result_sensitivity_ex4_expected"

print_section "Test Summary"
echo "Total tests: ${TOTAL_TESTS}"
echo "Passed: ${PASSED_TESTS}"
echo "Failed: ${FAILED_TESTS}"
echo ""

if [ ${FAILED_TESTS} -eq 0 ]; then
    print_success "All tests passed!"
    exit 0
else
    print_failure "Some tests failed. See output above for details."
    exit 1
fi
