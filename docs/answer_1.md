## 質問1：Φ符号の不整合と `MeanPhiMax` を確認すべきか

### 1) 数式としての正解（joint Gaussian のとき）

((X,Z)) が共同正規で、(Z^+=\max(0,Z)) とすると、厳密に

[
\mathrm{Cov}(X, Z^+) = \mathrm{Cov}(X,Z),\Phi!\left(\frac{\mu_Z}{\sigma_Z}\right)
]

が成り立ちます（(\Phi)は標準正規CDF、(\mu_Z=\mathbb{E}[Z])、(\sigma_Z=\sqrt{\mathrm{Var}(Z)})）。

この符号（(+\mu_Z/\sigma_Z)）は固定です。

### 2) 現行実装が間違いかどうかは `MeanPhiMax` 次第

あなたが見つけた

```cpp
double ms = -mu / sg;
double mpx = MeanPhiMax(ms);
double cov = c * mpx;
```

が **直ちに間違い**と言えるのは、`MeanPhiMax(x)` が **そのまま (\Phi(x))** を返している場合です。

* もし `MeanPhiMax(x) = Φ(x)` なら
  `ms=-mu/sg` → `Φ(-mu/sg)=1-Φ(mu/sg)` なので **誤り**です。

一方で、

* もし `MeanPhiMax(x) = Φ(-x)` を返す（名前は紛らわしいが実装でそうしている）なら
  `MeanPhiMax(-mu/sg)=Φ(mu/sg)` となり **正しい**です。
* もし `MeanPhiMax(x) = 1-Φ(x)` を返す実装なら
  `MeanPhiMax(-mu/sg)=1-Φ(-mu/sg)=Φ(mu/sg)` で **正しい**です。

### 3) どう直すのが一番安全か（推奨）

**確認は必須**です。その上で、今後の混乱を消すために次のどちらかを推奨します。

* 推奨A：`MeanPhiMax` を使わず、数値版でも **`Phi(mu/sg)` を明示**する
  （`Phi_std(x)=0.5*(1+erf(x/sqrt(2)))` 等）
* 推奨B：`MeanPhiMax` を使い続けるなら、関数名・コメントを **返す量が一意に分かる**ように変更
  例：`PhiStd(x)` / `OneMinusPhiStd(x)` / `PhiNegArg(x)` のように。

### 4) ここはテストで決着をつけるのが早い

joint Gaussian な ((X,Z)) を人工的に作り（平均・分散・共分散を指定）、Monte Carlo で

[
\widehat{\mathrm{Cov}}(X,\max(0,Z))
]

を推定し、実装値と一致することを確認すると、符号バグは一発で潰せます。

---

## 質問2：タイブレークにポインタ順は統合テストで問題か

あなたの指摘通りです：

* ✅ 同一プロセス内では決定的（同じアドレスなら同じ順）
* ❌ 実行間で非再現（ASLR等でアドレスが変わる）

### 1) 何が“問題”になるか

* **「順序依存の排除」だけが目的**なら、同一プロセス内の決定性でも最低限は達成できます。
  ただし、左右が変わることで **計算経路が変わり、数値が変わる実装のまま**だと、実行間で結果がぶれる可能性が残ります。
* CI の統合テストで **ゴールデン値（スナップショット）比較**をするなら、アドレス由来のぶれは普通に問題になります。

### 2) 推奨：安定ID（stable id）を導入

既存コードを活かしつつ、実行間再現性も欲しいなら、`RandomVariableImpl` に

* `uint64_t id;`（生成順に単調増加）
* あるいは「葉（Gaussian source）の固定ID + 式木の構造ハッシュ」

を持たせて、それでタイブレークしてください。

最小コストは **生成順ID**です。グラフ構築順が決定的なら、実行間でも一致します（テストが安定します）。

> なお「最終的に MAX 演算・Cov 演算が左右に依存しない設計（可換・対称な式）」になれば、タイブレークは**キャッシュ正規化**の目的だけになり、実行間ぶれの影響はほぼ消えます。

---
