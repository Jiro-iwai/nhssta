// -*- c++ -*-
// Authors: IWAI Jiro
// CriticalPathAnalyzer: Critical path analysis

#include "critical_path_analyzer.hpp"
#include "circuit_graph.hpp"
#include <nhssta/ssta_results.hpp>
#include <algorithm>
#include <cmath>
#include <limits>
#include <set>
#include <sstream>

namespace Nh {

CriticalPathAnalyzer::CriticalPathAnalyzer(const CircuitGraph& graph)
    : graph_(&graph) {
}

CriticalPaths CriticalPathAnalyzer::analyze(size_t top_n) const {
    CriticalPaths paths;
    
    const auto& outputs = graph_->outputs();
    const auto& dff_inputs = graph_->dff_inputs();
    
    if ((outputs.empty() && dff_inputs.empty()) || top_n == 0) {
        return paths;
    }
    
    const auto& signals = graph_->signals();
    const auto& signal_to_instance = graph_->signal_to_instance();
    const auto& instance_to_inputs = graph_->instance_to_inputs();
    const auto& instance_to_delays = graph_->instance_to_delays();
    const auto& inputs = graph_->inputs();
    const auto& dff_outputs = graph_->dff_outputs();
    
    auto build_node_stats = [&](const std::vector<std::string>& ordered_nodes) {
        LatResults stats;
        stats.reserve(ordered_nodes.size());
        for (const auto& node_name : ordered_nodes) {
            double mean = 0.0;
            double sigma = 0.0;
            std::string display_name = node_name;
            auto sig_it = signals.find(node_name);
            if (sig_it != signals.end()) {
                const RandomVariable& sig = sig_it->second;
                mean = sig->mean();
                double variance = sig->variance();
                sigma = variance > 0.0 ? std::sqrt(variance) : 0.0;
                display_name = sig->name();
            }
            stats.emplace_back(display_name, mean, sigma);
        }
        return stats;
    };
    
    auto is_source_node = [&](const std::string& name) {
        return inputs.find(name) != inputs.end() || dff_outputs.find(name) != dff_outputs.end();
    };
    
    auto finalize_path = [&](std::vector<std::string>& node_path, std::vector<std::string>& instance_path, double output_lat) {
        // Reverse node_path and instance_path for correct ordering (input to output)
        std::vector<std::string> reversed_nodes;
        reversed_nodes.reserve(node_path.size());
        reversed_nodes.assign(node_path.rbegin(), node_path.rend());
        std::vector<std::string> reversed_instances;
        reversed_instances.reserve(instance_path.size());
        reversed_instances.assign(instance_path.rbegin(), instance_path.rend());
        auto stats = build_node_stats(reversed_nodes);
        paths.emplace_back(std::move(reversed_nodes), std::move(reversed_instances), output_lat, std::move(stats));
        node_path.pop_back();
    };
    
    // Helper function to build path from output to input
    std::function<void(const std::string&, std::vector<std::string>&, std::vector<std::string>&, double)> build_path;
    build_path = [&](const std::string& signal_name, 
                     std::vector<std::string>& node_path,
                     std::vector<std::string>& instance_path,
                     double output_lat) {
        // Add current node to path
        node_path.push_back(signal_name);
        
        if (is_source_node(signal_name)) {
            finalize_path(node_path, instance_path, output_lat);
            return;
        }
        
        // Check if signal is generated by an instance
        auto inst_it = signal_to_instance.find(signal_name);
        if (inst_it == signal_to_instance.end()) {
            finalize_path(node_path, instance_path, output_lat);
            return;
        }
        
        const std::string& instance_name = inst_it->second;
        auto inputs_it = instance_to_inputs.find(instance_name);
        if (inputs_it == instance_to_inputs.end()) {
            node_path.pop_back();
            return;
        }
        
        const std::vector<std::string>& input_signals = inputs_it->second;
        
        // Get gate delays from saved data
        auto delays_it = instance_to_delays.find(instance_name);
        const std::unordered_map<std::string, Normal>* delays_map_ptr = nullptr;
        std::unordered_map<std::string, Normal> delays_map;
        if (delays_it != instance_to_delays.end()) {
            delays_map_ptr = &delays_it->second;
        }
        
        // Find the input signal that contributes to the critical path
        std::string critical_input;
        double max_contribution = std::numeric_limits<double>::lowest();
        
        int pin_index = 0;
        for (const auto& input_signal : input_signals) {
            auto input_sig_it = signals.find(input_signal);
            if (input_sig_it == signals.end()) {
                pin_index++;
                continue;
            }
            
            double input_lat = input_sig_it->second->mean();
            std::string pin_name = std::to_string(pin_index);
            
            const std::unordered_map<std::string, Normal>* map_to_search = delays_map_ptr ? delays_map_ptr : &delays_map;
            auto delay_it = map_to_search->find(pin_name);
            if (delay_it != map_to_search->end()) {
                const Normal& gate_delay = delay_it->second;
                double contribution = input_lat + gate_delay->mean();
                
                if (contribution > max_contribution) {
                    max_contribution = contribution;
                    critical_input = input_signal;
                }
            } else {
                if (input_lat > max_contribution) {
                    max_contribution = input_lat;
                    critical_input = input_signal;
                }
            }
            
            pin_index++;
        }
        
        // Add instance to path
        instance_path.push_back(instance_name);
        
        // Continue building path from critical input
        if (!critical_input.empty()) {
            build_path(critical_input, node_path, instance_path, output_lat);
        } else if (!input_signals.empty()) {
            build_path(input_signals[0], node_path, instance_path, output_lat);
        } else {
            finalize_path(node_path, instance_path, output_lat);
            return;
        }
        
        // Backtrack
        instance_path.pop_back();
        node_path.pop_back();
    };
    
    // Build paths from each output and DFF input
    std::set<std::string> path_endpoints;
    path_endpoints.insert(outputs.begin(), outputs.end());
    path_endpoints.insert(dff_inputs.begin(), dff_inputs.end());
    
    for (const auto& endpoint : path_endpoints) {
        auto sig_it = signals.find(endpoint);
        if (sig_it == signals.end()) {
            continue;
        }
        
        double endpoint_lat = sig_it->second->mean();
        
        std::vector<std::string> node_path;
        std::vector<std::string> instance_path;
        build_path(endpoint, node_path, instance_path, endpoint_lat);
    }
    
    // Sort paths by delay (descending), then by endpoint name (ascending) for stability
    std::sort(paths.begin(), paths.end(), 
              [](const CriticalPath& a, const CriticalPath& b) {
                  if (a.delay_mean != b.delay_mean) {
                      return a.delay_mean > b.delay_mean;
                  }
                  if (!a.node_names.empty() && !b.node_names.empty()) {
                      return a.node_names.back() < b.node_names.back();
                  }
                  return false;
              });
    
    if (paths.size() > top_n) {
        paths.resize(top_n);
    }
    
    return paths;
}

}  // namespace Nh

